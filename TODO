Timeouts
    * slow responses? (feasable? just let TCP do it?)

psgi.input streaming

    * add a "poll_cb()" method to the psgi.input handle as an extension?  EV
    gets to schedule the watcher in that case rather than bleeding the fd to
    the handler.
    * related: Connection: close bodies
    * related: Transfer-Encoding: chunked bodies

IO::Handle-like responses

    * check if it's got a real file descriptor, optimize (libeio for
    non-blocking sendfile?)
    * pump the getline() method when connection-writable

streamed responses

    * allow streaming responses to be HTTP/1.0 "Connection: close" rather than
    HTTP/1.1 "Transfer-Encoding: chunked".  match up the streaming flavour
    with the request version?

Handle requests that don't require a body (optional entities).

    * Related: allow overriding the "if entity has a C-L, wait for it" during request
    start (not sure if there's a PSGI-compatible way to do this)
    * different request timeout logic will be needed.

Better EV-callback error handling.

Lazy I/O watcher initialization?

Per-client "drain" and "completion" callbacks?

    * "drain" is effectively the poll_cb() ?
    * "completion" is when finished sending a full HTTP response (so apps can
    make request-completion assertions); could be accomplished with guards instead.

Per-client data (for attaching guards).

Translate sockaddr/etc. and put in env hash.

Un-corked reads - should newly accepted handles wait or just try read right
away?

sendfile via libeio/IO::AIO ?

multiple Feersum threads, one Perl thread?

WebSocket support

    * http://www.whatwg.org/specs/web-socket-protocol/
    * Do the handshake in C/XS, call request_handler once request is complete.
    * I/O is done using the streaming interface (buffered)
    * requires random numbers (drand48?) and an MD5 implementation (link
    openssl? use the guts of Digest::MD5 somehow?)
    * make this a separate module since if it brings in an openssl deps.
